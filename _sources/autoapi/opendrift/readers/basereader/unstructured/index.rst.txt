:mod:`opendrift.readers.basereader.unstructured`
================================================

.. py:module:: opendrift.readers.basereader.unstructured


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   opendrift.readers.basereader.unstructured.UnstructuredReader



.. data:: logger
   

   

.. py:class:: UnstructuredReader

   Bases: :class:`opendrift.readers.basereader.variables.Variables`

   An unstructured reader. Data is gridded irregularily.

   In order to support the heterogeneous types of unstructured grids, the
   unstructured readers are built up differently from the
   :class:`.structured.StructuredReader` readers. This class, which readers of
   unstructured grids subclass, provide several methods for aiding in
   interpolation and caching.

   The initial type of grid that this class supports are `triangular prisms <https://en.wikipedia.org/wiki/Types_of_mesh#Triangular_prism>`_. Unstructured in xy-coordinates, x and y is constant in z. z might be non-cartesian (e.g. sigma-levels).

   .. seealso::

       :py:mod:`opendrift.readers`

       :class:`.structured.StructuredReader`


   Caching using UnstructuredBlock:

   .. note::

       The `StructuredReader`s return a 2D field for `meshgrid(x,y)`. This is not
       so meaningful for `UnstructuredReader` since the variables are iregularily
       placed. The `get_variables` method should therefore be a method required by
       the `StructuredReader` and `ContinuousReader`, and maybe renamed to
       `get_block` for `StructuredReader`.

       For the `UnstructuredReader` we need the equivalent of `get_block`, maybe
       `get_subset` which sets up an `UnstructuredBlock` for the given area or
       volume. This probably requires :meth:`_get_variables_impl_`/ :meth:`__get_variables_derived__`
       to be moved to the outside of :meth:`_get_variables_interpolated_`.


   Initialize self.  See help(type(self)) for accurate signature.

   .. attribute:: boundary
      

      

   .. attribute:: x
      

      

   .. attribute:: y
      

      

   .. attribute:: node_variables
      

      

   .. attribute:: nodes_idx
      

      

   .. attribute:: xc
      

      

   .. attribute:: yc
      

      

   .. attribute:: face_variables
      

      

   .. attribute:: faces_idx
      

      

   .. method:: _get_variables_interpolated_(self, variables, profiles, profiles_depth, time, reader_x, reader_y, z)

      Implemented by different reader types (e.g. :class:`structured.StructuredReader`).

      Arguments are in native projection of reader.


   .. method:: _build_boundary_polygon_(self, x, y)

      Build a polygon of the boundary of the mesh.

      Arguments:
          :param x: Array of node x position, lenght N
          :param y: Array of node y position, length N

      Returns:
          A `shapely.prepareped.prep` `shapely.Polygon`.

          The boundary of the mesh, ideally including holes in the mesh.

      Algorithms:

      .. note::

          Try this alogrithm: https://stackoverflow.com/a/14109211/377927

          Boundary edges (line between two nodes) are only referenced by a single
          triangle.

          1. Find a starting edge segment: [v_start, v_next] (v is vertex or node)

          2. Find another _unvisited_ edge segment [v_i, v_j] that has
             either v_i = v_next or v_j = v_next and add the one not equal to v_next to the polygon.

          3. Reset v_next to the newly added point. Mark edge as visited.

          4. Continue untill we reach v_start.

          The polygon has a rotation, but this should not matter for our purpose
          of checking the bounds.

          Note: In order to find holes in the polygon all points must be scanned.

      Approximate using the convex hull:

      An alternative simple approximation is to use the convex hull of the
      points, but this will miss points along the boundary which form a
      wedge in the boundary (as well as holes in the mesh).

      Holes in the mesh will often be covered by the landmask anyway, so they
      will usually not be a problem.


   .. method:: covers_positions(self, x, y, z=0)

      Check which points are within boundary of mesh.


   .. method:: _build_rtree_(self, x, y)

      Builds an R-tree of x, y


   .. method:: _build_ckdtree_(self, x, y)


   .. method:: __nearest_ckdtree__(idx, x, y)
      :staticmethod:

      Return index of nearest point in cKDTree


   .. method:: __nearest_rtree__(idx, x, y)
      :staticmethod:

      Take array of points and get nearest point in rtree index.


   .. method:: _nearest_node_(self, x, y)

      Return nearest node (id) for x and y


   .. method:: _nearest_face_(self, xc, yc)

      Return nearest element or face (id) for xc and yc



