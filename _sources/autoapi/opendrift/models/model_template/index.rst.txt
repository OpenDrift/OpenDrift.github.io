:mod:`opendrift.models.model_template`
======================================

.. py:module:: opendrift.models.model_template

.. autoapi-nested-parse::

   This file is a template for an ocean trajectory model
   to be implemented within the OpenDrift framework.
   To create a new model, make a copy (renamed) of this file, and
   modify the class names and details below, according to the comments.
   See e.g. module windblow.py for a minimalistic example.

   For more help, see https://github.com/OpenDrift/opendrift/wiki
   or contact Knut-Frode Dagestad (knutfd@met.no)
   For usage of the new model, see example scripts (e.g. example.py)

   First we define an element type to be used by the trajectory model.
   An element type (class) may also be imported/reused from
   another module - see examples in the folder "elements"



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   opendrift.models.model_template.TemplateElementType
   opendrift.models.model_template.ModelTemplate



.. py:class:: TemplateElementType(**kwargs)

   Bases: :class:`opendrift.models.oceandrift.Lagrangian3DArray`

   Extending LagrangianArray with relevant properties.

   Define and name the properties which the elements shall have.
   These are added to the inherited properties (e.g. from OceanDrift)
   Property names may be freely chosen, but the "update" function (below)
   will refer to the names in the specifications of the processes.

   .. attribute:: variables
      

      


.. py:class:: ModelTemplate(*args, **kwargs)

   Bases: :class:`opendrift.models.oceandrift.OceanDrift`

   Open source trajectory model based on the OpenDrift framework.

   This is a template model, to be copied and modified according to need.
   This class is a subclass of "OceanDrift", and thus inherits all its
   functionality. More specialised models may also be subclassed.

   .. attribute:: ElementType
      

      

   .. attribute:: required_variables
      :annotation: = ['x_sea_water_velocity', 'y_sea_water_velocity', 'x_wind', 'y_wind', 'land_binary_mask']

      

   .. attribute:: fallback_values
      

      

   .. method:: update(self)

      Update positions and properties of particles.

      This function (``update``, may not be renamed) defines
      the actions (processes) to be performed at each time step.
      The default timestep is one hour, but this may be overriden
      by the user.

      The elements and corresponding environment information
      (wind, waves, current...) is available to this function as
      the recarrays ``elements`` and ``environment``, respectively.
      Element properties and environvent variables are named arrays
      of same length (number of active particles), or scalars.

      E.g.:

      .. code::

          self.elements.z
          self.elements.mass
          self.environment.x_wind
          self.environment.y_wind

      E.g. to specify evaporation (mass reduction) proportional to wind speed:

      .. code::

          self.elements.mass = self.elements.mass -                 np.sqrt(self.environment.x_wind**2 +                         self.environment.y_wind**2)*.01

      If particles need to be deactived (e.g. if
      self.environemtn.someproperty is 0), the special function
      `self.deactivate_elements()` should be used:
      `self.deactivate_elements(self.environment.someproperty==0)`

      Interaction with coast is handled by ``basemodel`` and is
      chosen with configutation mechanism available to each module.

      Horizontal position of the particles (lon, lat) are the
      only properties which should not be modified directly/freely.
      Due to the need to correct for the curvature of the coordinate
      systems, and taking into account vector orientations, a dedicated 
      method ``self.update_positions()`` is
      available using x- and y-velocity as arguments:
      E.g. to simply move particles with ambient current:
      ``
      self.update_positions(self.environment.x_sea_water_velocity,
                            self.environment.y_sea_water_velocity)``

      However, instead of using this method directly, most
      OpenDrift modules use a set of ready-made and reusable
      advection methods, added below. 


   .. method:: prepare_run(self)

      Code to be run before a simulation loop (``update()``)


   .. method:: bottom_interaction(self, seafloor_depth)

      Sub method of vertical_mixing, determines settling



