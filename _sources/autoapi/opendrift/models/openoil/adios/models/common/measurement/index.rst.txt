:py:mod:`opendrift.models.openoil.adios.models.common.measurement`
==================================================================

.. py:module:: opendrift.models.openoil.adios.models.common.measurement

.. autoapi-nested-parse::

   Generic Measurement Types

   These are structures that handle an individual measurment:

   They have a value, a unit type and a unit.

   They can be converted to other units if need be.

   They can accommodate a single value, or a range of values

   They can also accommodate a standard deviation and number of replicates.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   opendrift.models.openoil.adios.models.common.measurement.Temperature
   opendrift.models.openoil.adios.models.common.measurement.Unitless
   opendrift.models.openoil.adios.models.common.measurement.Dimensionless
   opendrift.models.openoil.adios.models.common.measurement.Time
   opendrift.models.openoil.adios.models.common.measurement.Length
   opendrift.models.openoil.adios.models.common.measurement.Mass
   opendrift.models.openoil.adios.models.common.measurement.Concentration
   opendrift.models.openoil.adios.models.common.measurement.MassFraction
   opendrift.models.openoil.adios.models.common.measurement.VolumeFraction
   opendrift.models.openoil.adios.models.common.measurement.AnyUnit
   opendrift.models.openoil.adios.models.common.measurement.Density
   opendrift.models.openoil.adios.models.common.measurement.DynamicViscosity
   opendrift.models.openoil.adios.models.common.measurement.KinematicViscosity
   opendrift.models.openoil.adios.models.common.measurement.Pressure
   opendrift.models.openoil.adios.models.common.measurement.NeedleAdhesion
   opendrift.models.openoil.adios.models.common.measurement.InterfacialTension
   opendrift.models.openoil.adios.models.common.measurement.AngularVelocity




.. py:class:: Temperature

   Bases: :py:obj:`MeasurementBase`

   Data structure to hold a value with a unit

   This accommodates both a single value and a range of values

   There is some complexity here, so everything is optional

   NOTE: another reason for everything to be optional is that
   when working with the web client, empty measurements can be
   created and saved before the values are filled in.

   NOTES:
      If there is a value, there should be no min_value or max_value
      If there is only  a min or max, then it is interpreted as
      greater than or less than

      There needs to be validation on that!

      Fixme: maybe there could be a default unit for each unit type?

   .. py:attribute:: unit_type
      :value: 'temperature'

      

   .. py:attribute:: fixCK
      :value: False

      

   .. py:method:: __post_init__()

      this here so that it can get overidden in subclasses

      it appears dataclasses don't add it to __init__ unless it's here


   .. py:method:: convert_to(new_unit)

      Convert this Measurement object to the specified new unit

      The object is mutated in place.

      If the conversion can not be performed, an Exception will
      be raised, and the object not altered.

      This will also return the object (self) -- but that is a
      deprecated feature -- do not use it!

      If you want a new object, use `converted_to` instead


   .. py:method:: validate()


   .. py:method:: fix_C_K()

      This is a bit of a kludge:

      The correct conversion from C to K is 273.16

      But a lot of data sources (notably the ADIOS2 database)
      used 273.0.

      So we end up with temps like: -0.15 C instead of 0.0 C
      This function will "correct" that.

      Note: it also converts to C



.. py:class:: Unitless

   Bases: :py:obj:`MeasurementBase`

   This is a type for data with no unit at all.

   .. py:attribute:: unit_type
      :value: 'unitless'

      

   .. py:method:: convert_to(*args, **kwargs)

      Convert this Measurement object to the specified new unit

      The object is mutated in place.

      If the conversion can not be performed, an Exception will
      be raised, and the object not altered.

      This will also return the object (self) -- but that is a
      deprecated feature -- do not use it!

      If you want a new object, use `converted_to` instead



.. py:class:: Dimensionless

   Bases: :py:obj:`MeasurementBase`

   This is a type that can be converted to generic fractional amounts,
   but does not refer to a particular measurable quantity.

   .. py:attribute:: unit_type
      :value: 'dimensionless'

      


.. py:class:: Time

   Bases: :py:obj:`MeasurementBase`

   Data structure to hold a value with a unit

   This accommodates both a single value and a range of values

   There is some complexity here, so everything is optional

   NOTE: another reason for everything to be optional is that
   when working with the web client, empty measurements can be
   created and saved before the values are filled in.

   NOTES:
      If there is a value, there should be no min_value or max_value
      If there is only  a min or max, then it is interpreted as
      greater than or less than

      There needs to be validation on that!

      Fixme: maybe there could be a default unit for each unit type?

   .. py:attribute:: unit_type
      :value: 'time'

      


.. py:class:: Length

   Bases: :py:obj:`MeasurementBase`

   Data structure to hold a value with a unit

   This accommodates both a single value and a range of values

   There is some complexity here, so everything is optional

   NOTE: another reason for everything to be optional is that
   when working with the web client, empty measurements can be
   created and saved before the values are filled in.

   NOTES:
      If there is a value, there should be no min_value or max_value
      If there is only  a min or max, then it is interpreted as
      greater than or less than

      There needs to be validation on that!

      Fixme: maybe there could be a default unit for each unit type?

   .. py:attribute:: unit_type
      :value: 'length'

      


.. py:class:: Mass

   Bases: :py:obj:`MeasurementBase`

   Data structure to hold a value with a unit

   This accommodates both a single value and a range of values

   There is some complexity here, so everything is optional

   NOTE: another reason for everything to be optional is that
   when working with the web client, empty measurements can be
   created and saved before the values are filled in.

   NOTES:
      If there is a value, there should be no min_value or max_value
      If there is only  a min or max, then it is interpreted as
      greater than or less than

      There needs to be validation on that!

      Fixme: maybe there could be a default unit for each unit type?

   .. py:attribute:: unit_type
      :value: 'mass'

      


.. py:class:: Concentration

   Bases: :py:obj:`MeasurementBase`

   Data structure to hold a value with a unit

   This accommodates both a single value and a range of values

   There is some complexity here, so everything is optional

   NOTE: another reason for everything to be optional is that
   when working with the web client, empty measurements can be
   created and saved before the values are filled in.

   NOTES:
      If there is a value, there should be no min_value or max_value
      If there is only  a min or max, then it is interpreted as
      greater than or less than

      There needs to be validation on that!

      Fixme: maybe there could be a default unit for each unit type?

   .. py:attribute:: unit_type
      :value: 'concentration'

      


.. py:class:: MassFraction

   Bases: :py:obj:`MeasurementBase`

   Data structure to hold a value with a unit

   This accommodates both a single value and a range of values

   There is some complexity here, so everything is optional

   NOTE: another reason for everything to be optional is that
   when working with the web client, empty measurements can be
   created and saved before the values are filled in.

   NOTES:
      If there is a value, there should be no min_value or max_value
      If there is only  a min or max, then it is interpreted as
      greater than or less than

      There needs to be validation on that!

      Fixme: maybe there could be a default unit for each unit type?

   .. py:attribute:: unit_type
      :value: 'massfraction'

      


.. py:class:: VolumeFraction

   Bases: :py:obj:`MeasurementBase`

   Data structure to hold a value with a unit

   This accommodates both a single value and a range of values

   There is some complexity here, so everything is optional

   NOTE: another reason for everything to be optional is that
   when working with the web client, empty measurements can be
   created and saved before the values are filled in.

   NOTES:
      If there is a value, there should be no min_value or max_value
      If there is only  a min or max, then it is interpreted as
      greater than or less than

      There needs to be validation on that!

      Fixme: maybe there could be a default unit for each unit type?

   .. py:attribute:: unit_type
      :value: 'volumefraction'

      


.. py:class:: AnyUnit(*args, **kwargs)

   Bases: :py:obj:`MeasurementBase`

   This is a type for data that could be any unit_type

   .. py:method:: __post_init__()

      We don't need the post_init in this case

      overriding it to disable it


   .. py:method:: __eq__(other)

      So as not to be pedantic with the class -- if the values all match



.. py:class:: Density

   Bases: :py:obj:`MeasurementBase`

   Data structure to hold a value with a unit

   This accommodates both a single value and a range of values

   There is some complexity here, so everything is optional

   NOTE: another reason for everything to be optional is that
   when working with the web client, empty measurements can be
   created and saved before the values are filled in.

   NOTES:
      If there is a value, there should be no min_value or max_value
      If there is only  a min or max, then it is interpreted as
      greater than or less than

      There needs to be validation on that!

      Fixme: maybe there could be a default unit for each unit type?

   .. py:attribute:: unit_type
      :value: 'density'

      


.. py:class:: DynamicViscosity

   Bases: :py:obj:`MeasurementBase`

   Data structure to hold a value with a unit

   This accommodates both a single value and a range of values

   There is some complexity here, so everything is optional

   NOTE: another reason for everything to be optional is that
   when working with the web client, empty measurements can be
   created and saved before the values are filled in.

   NOTES:
      If there is a value, there should be no min_value or max_value
      If there is only  a min or max, then it is interpreted as
      greater than or less than

      There needs to be validation on that!

      Fixme: maybe there could be a default unit for each unit type?

   .. py:attribute:: unit_type
      :value: 'dynamicviscosity'

      


.. py:class:: KinematicViscosity

   Bases: :py:obj:`MeasurementBase`

   Data structure to hold a value with a unit

   This accommodates both a single value and a range of values

   There is some complexity here, so everything is optional

   NOTE: another reason for everything to be optional is that
   when working with the web client, empty measurements can be
   created and saved before the values are filled in.

   NOTES:
      If there is a value, there should be no min_value or max_value
      If there is only  a min or max, then it is interpreted as
      greater than or less than

      There needs to be validation on that!

      Fixme: maybe there could be a default unit for each unit type?

   .. py:attribute:: unit_type
      :value: 'kinematicviscosity'

      


.. py:class:: Pressure

   Bases: :py:obj:`MeasurementBase`

   Data structure to hold a value with a unit

   This accommodates both a single value and a range of values

   There is some complexity here, so everything is optional

   NOTE: another reason for everything to be optional is that
   when working with the web client, empty measurements can be
   created and saved before the values are filled in.

   NOTES:
      If there is a value, there should be no min_value or max_value
      If there is only  a min or max, then it is interpreted as
      greater than or less than

      There needs to be validation on that!

      Fixme: maybe there could be a default unit for each unit type?

   .. py:attribute:: unit_type
      :value: 'pressure'

      


.. py:class:: NeedleAdhesion

   Bases: :py:obj:`MeasurementBase`

   Data structure to hold a value with a unit

   This accommodates both a single value and a range of values

   There is some complexity here, so everything is optional

   NOTE: another reason for everything to be optional is that
   when working with the web client, empty measurements can be
   created and saved before the values are filled in.

   NOTES:
      If there is a value, there should be no min_value or max_value
      If there is only  a min or max, then it is interpreted as
      greater than or less than

      There needs to be validation on that!

      Fixme: maybe there could be a default unit for each unit type?

   .. py:attribute:: unit_type
      :value: 'needleadhesion'

      


.. py:class:: InterfacialTension

   Bases: :py:obj:`MeasurementBase`

   Data structure to hold a value with a unit

   This accommodates both a single value and a range of values

   There is some complexity here, so everything is optional

   NOTE: another reason for everything to be optional is that
   when working with the web client, empty measurements can be
   created and saved before the values are filled in.

   NOTES:
      If there is a value, there should be no min_value or max_value
      If there is only  a min or max, then it is interpreted as
      greater than or less than

      There needs to be validation on that!

      Fixme: maybe there could be a default unit for each unit type?

   .. py:attribute:: unit_type
      :value: 'interfacialtension'

      


.. py:class:: AngularVelocity

   Bases: :py:obj:`MeasurementBase`

   Data structure to hold a value with a unit

   This accommodates both a single value and a range of values

   There is some complexity here, so everything is optional

   NOTE: another reason for everything to be optional is that
   when working with the web client, empty measurements can be
   created and saved before the values are filled in.

   NOTES:
      If there is a value, there should be no min_value or max_value
      If there is only  a min or max, then it is interpreted as
      greater than or less than

      There needs to be validation on that!

      Fixme: maybe there could be a default unit for each unit type?

   .. py:attribute:: unit_type
      :value: 'angularvelocity'

      


