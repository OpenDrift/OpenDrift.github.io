<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>opendrift.readers.reader_schism_native &mdash; OpenDrift  documentation</title>
      <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> OpenDrift
            <img src="../../../_static/opendrift_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Introduction to OpenDrift</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../history_link.html">History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing OpenDrift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../theory/index.html">Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../choosing_a_model.html">How to choose which model to use</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../writing_a_new_model.html">How to write a new module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../oil_types.html">Oil types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../interaction_with_coastline.html">Interaction with coastline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docker.html">Using OpenDrift in a container</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gui.html">Graphical User Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../services.html">Services using OpenDrift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/index.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">OpenDrift</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
          <li><a href="../../opendrift.html">opendrift</a> &raquo;</li>
          <li><a href="../readers.html">opendrift.readers</a> &raquo;</li>
      <li>opendrift.readers.reader_schism_native</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for opendrift.readers.reader_schism_native</h1><div class="highlight"><pre>
<span></span><span class="c1"># This file is part of OpenDrift.</span>
<span class="c1">#</span>
<span class="c1"># OpenDrift is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, version 2</span>
<span class="c1">#</span>
<span class="c1"># OpenDrift is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with OpenDrift.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">##########################################################################</span>
<span class="c1"># This reader supports native SCHISM output netcdf files and will</span>
<span class="c1"># handle interpolation of current velocities and other variables</span>
<span class="c1"># in 2D and 3D.</span>
<span class="c1"># The interpolation is done using a cKDtree-approach defined</span>
<span class="c1"># form the 2D or 3D mesh nodes</span>
<span class="c1">#</span>
<span class="c1"># Author: Simon Weppe. MetOcean Solution, MetService New Zealand</span>
<span class="c1">##########################################################################</span>

<span class="c1">##########################################################################</span>
<span class="c1"># This version aims to be more consistent with the new Opendrift release,</span>
<span class="c1"># and re-uses some of the methods in unstructured.py, and better follow</span>
<span class="c1"># the new logics</span>
<span class="c1">#</span>
<span class="c1"># Note the interpolation approach is closer to what is done in</span>
<span class="c1"># structured.py with cached reader &quot;blocks&quot; that are re-used for</span>
<span class="c1"># successive interpolation between two model time steps.</span>
<span class="c1"># unstructured.py instead of reading data at each interpolation cycle</span>
<span class="c1">#</span>
<span class="c1">##########################################################################</span>


<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">netCDF4</span> <span class="kn">import</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">MFDataset</span><span class="p">,</span> <span class="n">num2date</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">LinearNDInterpolator</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">cKDTree</span> <span class="c1">#cython-based KDtree for quick nearest-neighbor search</span>
<span class="kn">import</span> <span class="nn">pyproj</span>
<span class="kn">from</span> <span class="nn">opendrift.readers.basereader</span> <span class="kn">import</span> <span class="n">BaseReader</span><span class="p">,</span> <span class="n">UnstructuredReader</span>
<span class="kn">from</span> <span class="nn">opendrift.readers.basereader.consts</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
    <span class="n">has_xarray</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">has_xarray</span> <span class="o">=</span> <span class="kc">False</span>


<div class="viewcode-block" id="Reader"><a class="viewcode-back" href="../../../autoapi/opendrift/readers/reader_schism_native/index.html#opendrift.readers.reader_schism_native.Reader">[docs]</a><span class="k">class</span> <span class="nc">Reader</span><span class="p">(</span><span class="n">BaseReader</span><span class="p">,</span><span class="n">UnstructuredReader</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A reader for unstructured (irregularily gridded) `SCHISM` files.</span>

<span class="sd">    Args:</span>
<span class="sd">        :param filename: a single SCHISM netcdf output file, or a pattern of files.</span>
<span class="sd">                         The netCDF file can also be an URL to an OPeNDAP server.</span>
<span class="sd">        :type filename: string, required.</span>

<span class="sd">        :param name: Name of reader</span>
<span class="sd">        :type name: string, optional</span>

<span class="sd">        :param proj4: PROJ.4 string describing projection of data.</span>
<span class="sd">        :type proj4: string, optional</span>

<span class="sd">        :param use_3d: switch to use 3d flows (if available)</span>
<span class="sd">        :type use_3d: boolean, optional</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        py:mod:`opendrift.readers.basereader.unstructured`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">proj4</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_3d</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Need filename as argument to constructor&#39;</span><span class="p">)</span>
        <span class="n">filestr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">filestr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="c1"># Default interpolation method, see function interpolate_block()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span> <span class="o">=</span> <span class="s1">&#39;linearNDFast&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convolve</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Convolution kernel or kernel size</span>

        <span class="c1"># [name_used_in_schism : equivalent_CF_name used in opendrift]</span>
        <span class="n">schism_mapping</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;dahv&#39;</span><span class="p">:</span> <span class="s1">&#39;x_sea_water_velocity&#39;</span><span class="p">,</span>
            <span class="s1">&#39;dahv&#39;</span><span class="p">:</span> <span class="s1">&#39;y_sea_water_velocity&#39;</span><span class="p">,</span>
            <span class="s1">&#39;hvel&#39;</span><span class="p">:</span> <span class="s1">&#39;x_sea_water_velocity&#39;</span><span class="p">,</span>
            <span class="s1">&#39;hvel&#39;</span><span class="p">:</span> <span class="s1">&#39;y_sea_water_velocity&#39;</span><span class="p">,</span>
            <span class="s1">&#39;depth&#39;</span><span class="p">:</span> <span class="s1">&#39;sea_floor_depth_below_sea_level&#39;</span><span class="p">,</span>
            <span class="s1">&#39;elev&#39;</span> <span class="p">:</span> <span class="s1">&#39;sea_surface_height&#39;</span><span class="p">,</span>
            <span class="s1">&#39;temp&#39;</span> <span class="p">:</span> <span class="s1">&#39;sea_water_temperature&#39;</span><span class="p">,</span>
            <span class="s1">&#39;salt&#39;</span> <span class="p">:</span> <span class="s1">&#39;sea_water_salinity&#39;</span><span class="p">,</span>
            <span class="s1">&#39;zcor&#39;</span> <span class="p">:</span> <span class="s1">&#39;vertical_levels&#39;</span><span class="p">,</span> <span class="c1"># time-varying vertical coordinates</span>
            <span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="s1">&#39;ocean_s_coordinate&#39;</span><span class="p">,</span>
            <span class="s1">&#39;vertical_velocity&#39;</span> <span class="p">:</span> <span class="s1">&#39;upward_sea_water_velocity&#39;</span><span class="p">}</span>
            <span class="c1"># diffusivity</span>
            <span class="c1"># viscosity</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">return_block</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Open file, check that everything is ok</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Opening dataset: &#39;</span> <span class="o">+</span> <span class="n">filestr</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;*&#39;</span> <span class="ow">in</span> <span class="n">filestr</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;?&#39;</span> <span class="ow">in</span> <span class="n">filestr</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;[&#39;</span> <span class="ow">in</span> <span class="n">filestr</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Opening files with MFdataset&#39;</span><span class="p">)</span>
                <span class="c1"># self.dataset = MFdataset(filename)</span>
                <span class="k">if</span> <span class="n">has_xarray</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_mfdataset</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">chunks</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">MFDataset</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">aggdim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Opening file with dataset&#39;</span><span class="p">)</span>
                <span class="c1"># self.dataset = dataset(filename, &#39;r&#39;)</span>
                <span class="k">if</span> <span class="n">has_xarray</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">chunks</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="c1"># Define projection of input data</span>
        <span class="k">if</span> <span class="n">proj4</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1">#  user has provided a projection apriori</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proj4</span> <span class="o">=</span> <span class="n">proj4</span>
        <span class="k">else</span><span class="p">:</span>                 <span class="c1"># no input assumes latlon</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Lon and lat are 1D arrays, assuming latlong projection: proj4 = &#39;&#39;+proj=latlong&#39;&#39;&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proj4</span> <span class="o">=</span> <span class="s1">&#39;+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs&#39;</span> <span class="c1">#&#39;+proj=latlong&#39;</span>

        <span class="c1"># check if 3d data is available and if we should use it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_3d</span> <span class="o">=</span> <span class="n">use_3d</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_3d</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span> <span class="c1"># not specified, use 3d data by default (if available)</span>
            <span class="k">if</span> <span class="s1">&#39;hvel&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_3d</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_3d</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_3d</span> <span class="ow">and</span> <span class="s1">&#39;hvel&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;No 3D velocity data in file - cannot find variable &#39;&#39;hvel&#39;&#39; &#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_3d</span> <span class="ow">and</span> <span class="s1">&#39;hvel&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;zcor&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span> <span class="c1"># both hvel and zcor in files - all good</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nb_levels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;hvel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1">#hvel dimensions : [time,node,lev,2]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;No vertical level information present in file &#39;&#39;zcor&#39;&#39; ... stopping&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;variable &#39;&#39;zcor&#39;&#39; must be present in netcdf file to be able to use 3D currents&#39;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Finding coordinate variables.&#39;</span><span class="p">)</span>
        <span class="c1"># Find x, y and z coordinates</span>
        <span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;SCHISM_hgrid_face_x&#39;</span><span class="p">,</span><span class="s1">&#39;SCHISM_hgrid_face_y&#39;</span><span class="p">,</span><span class="s1">&#39;SCHISM_hgrid_edge_x&#39;</span><span class="p">,</span><span class="s1">&#39;SCHISM_hgrid_edge_y&#39;</span><span class="p">]:</span>
                <span class="c1"># all these variables have the same standard name projection_x_coordinate,projection_y_coordinate</span>
                <span class="c1"># we need to only use :</span>
                <span class="c1"># SCHISM_hgrid_node_x as projection_x_coordinate</span>
                <span class="c1"># SCHISM_hgrid_node_y as projection_y_coordinate</span>
                <span class="c1"># which are the nodes (also called vertices)</span>
                <span class="k">continue</span>

            <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">has_xarray</span><span class="p">:</span>
                <span class="n">attributes</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">attrs</span>
                <span class="n">att_dict</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">attrs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">attributes</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">()</span>
                <span class="n">att_dict</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="vm">__dict__</span>
            <span class="n">standard_name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">long_name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">CoordinateAxisType</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">if</span> <span class="s1">&#39;standard_name&#39;</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
                <span class="n">standard_name</span> <span class="o">=</span> <span class="n">att_dict</span><span class="p">[</span><span class="s1">&#39;standard_name&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s1">&#39;long_name&#39;</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
                <span class="n">long_name</span> <span class="o">=</span> <span class="n">att_dict</span><span class="p">[</span><span class="s1">&#39;long_name&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s1">&#39;axis&#39;</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="n">att_dict</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s1">&#39;units&#39;</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
                <span class="n">units</span> <span class="o">=</span> <span class="n">att_dict</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s1">&#39;_CoordinateAxisType&#39;</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
                <span class="n">CoordinateAxisType</span> <span class="o">=</span> <span class="n">att_dict</span><span class="p">[</span><span class="s1">&#39;_CoordinateAxisType&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">standard_name</span> <span class="o">==</span> <span class="s1">&#39;longitude&#39;</span> <span class="ow">or</span> \
                    <span class="n">long_name</span> <span class="o">==</span> <span class="s1">&#39;longitude&#39;</span> <span class="ow">or</span> \
                    <span class="n">var_name</span> <span class="o">==</span> <span class="s1">&#39;longitude&#39;</span> <span class="ow">or</span> \
                    <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span> <span class="ow">or</span> \
                    <span class="n">CoordinateAxisType</span> <span class="o">==</span> <span class="s1">&#39;Lon&#39;</span> <span class="ow">or</span> \
                    <span class="n">standard_name</span> <span class="o">==</span> <span class="s1">&#39;projection_x_coordinate&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xname</span> <span class="o">=</span> <span class="n">var_name</span>
                <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># When datasets are concatenated by mfdataset(), coordinates vector (1D) may</span>
                    <span class="c1"># be tiled to a 2D array of size (time,node), keep only one vector for x,y</span>
                    <span class="n">var</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
                <span class="c1"># Fix for units; should ideally use udunits package</span>
                <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;km&#39;</span><span class="p">:</span>
                    <span class="n">unitfactor</span> <span class="o">=</span> <span class="mi">1000</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unitfactor</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">has_xarray</span><span class="p">:</span>
                    <span class="n">var_data</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">values</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">var_data</span> <span class="o">=</span> <span class="n">var</span><span class="p">[:]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">var_data</span><span class="o">*</span><span class="n">unitfactor</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unitfactor</span> <span class="o">=</span> <span class="n">unitfactor</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">numx</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">standard_name</span> <span class="o">==</span> <span class="s1">&#39;latitude&#39;</span> <span class="ow">or</span> \
                    <span class="n">long_name</span> <span class="o">==</span> <span class="s1">&#39;latitude&#39;</span> <span class="ow">or</span> \
                    <span class="n">var_name</span> <span class="o">==</span> <span class="s1">&#39;latitude&#39;</span> <span class="ow">or</span> \
                    <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;Y&#39;</span> <span class="ow">or</span> \
                    <span class="n">CoordinateAxisType</span> <span class="o">==</span> <span class="s1">&#39;Lat&#39;</span> <span class="ow">or</span> \
                    <span class="n">standard_name</span> <span class="o">==</span> <span class="s1">&#39;projection_y_coordinate&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">yname</span> <span class="o">=</span> <span class="n">var_name</span>
                <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">var</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
                <span class="c1"># Fix for units; should ideally use udunits package</span>
                <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;km&#39;</span><span class="p">:</span>
                    <span class="n">unitfactor</span> <span class="o">=</span> <span class="mi">1000</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unitfactor</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">has_xarray</span><span class="p">:</span>
                    <span class="n">var_data</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">values</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">var_data</span> <span class="o">=</span> <span class="n">var</span><span class="p">[:]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">var_data</span><span class="o">*</span><span class="n">unitfactor</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">numy</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">standard_name</span> <span class="o">==</span> <span class="s1">&#39;depth&#39;</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">has_xarray</span><span class="p">:</span>
                    <span class="n">var_data</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">values</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">var_data</span> <span class="o">=</span> <span class="n">var</span><span class="p">[:]</span>
                <span class="k">if</span> <span class="s1">&#39;positive&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">()</span> <span class="ow">or</span> \
                        <span class="n">var</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;positive&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;up&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">var_data</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="n">var_data</span>
            <span class="k">if</span> <span class="n">standard_name</span> <span class="o">==</span> <span class="s1">&#39;time&#39;</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;T&#39;</span> <span class="ow">or</span> <span class="n">var_name</span> <span class="o">==</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">has_xarray</span><span class="p">:</span>
                    <span class="n">var_data</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">values</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">var_data</span> <span class="o">=</span> <span class="n">var</span><span class="p">[:]</span>
                <span class="c1"># Read and store time coverage (of this particular file)</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">var_data</span>
                <span class="n">time_units</span> <span class="o">=</span> <span class="n">units</span>
                <span class="k">if</span> <span class="n">has_xarray</span><span class="p">:</span>
                    <span class="c1"># convert from numpy.datetime64 to datetime</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="n">datetime</span><span class="o">.</span><span class="n">utcfromtimestamp</span><span class="p">((</span><span class="n">OT</span> <span class="o">-</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;1970-01-01T00:00:00Z&#39;</span><span class="p">)</span>
                            <span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">OT</span> <span class="ow">in</span> <span class="n">time</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">num2date</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">time_units</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time_step</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="s1">&#39;x&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Did not find x-coordinate variable&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;y&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Did not find y-coordinate variable&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">&gt;</span><span class="mf">360.</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_3d</span> <span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Native (x,y) coordinates are lon/lat - cannot use 3D data, setting use_3d = False&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_3d</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="kn">import</span> <span class="nn">pdb</span><span class="p">;</span><span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
            <span class="c1"># the 3D interpolation currently doesnt work if the x,y coordinates in native netcdf files</span>
            <span class="c1"># are not cartesian but geographic. If that is the case, when doing 3D interpolation and tree search,</span>
            <span class="c1"># the vertical distance unit is meter, while the horizontal distance unit is degrees, which will return</span>
            <span class="c1"># erroneous &quot;closest&quot; nodes in ReaderBlockUnstruct,interpolate()</span>

        <span class="c1"># Run constructor of parent Reader class</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Reader</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># compute CKDtree of (static) 2D nodes using _build_ckdtree_() from unstructured.py</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Building CKDtree of static 2D nodes for nearest-neighbor search&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reader_KDtree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_ckdtree_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># build convex hull of points for particle-in-mesh checks using _build_boundary_polygon_() from unstructured.py</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Building convex hull of nodes for particle&#39;&#39;s in-mesh checks&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_boundary_polygon_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># Find all variables having standard_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_mapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yname</span><span class="p">]:</span> <span class="c1">#&#39;depth&#39;</span>
                <span class="k">continue</span>  <span class="c1"># Skip coordinate variables</span>
            <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">has_xarray</span><span class="p">:</span>
                <span class="n">attributes</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">attrs</span>
                <span class="n">att_dict</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">attrs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">attributes</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">()</span>
                <span class="n">att_dict</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="vm">__dict__</span>

            <span class="k">if</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">schism_mapping</span><span class="p">:</span>
                <span class="c1"># current velocity variables [&#39;dahv&#39;,&#39;hvel&#39;] need special treatment because</span>
                <span class="c1"># [u,v] components are saved in the same variable i.e.</span>
                <span class="c1"># u = nc.variables[&#39;hvel&#39;][0,:,:]</span>
                <span class="c1"># v = nc.variables[&#39;hvel&#39;][1,:,:]</span>
                <span class="c1">#</span>
                <span class="c1"># this means both x_sea_water_velocity and y_sea_water_velocity</span>
                <span class="c1"># will be mapped to same name. Correct data will be then extracted</span>
                <span class="c1"># in get_variables()</span>
                <span class="c1">#</span>
                <span class="k">if</span> <span class="n">var_name</span> <span class="o">==</span> <span class="s1">&#39;hvel&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_3d</span> <span class="p">:</span> <span class="c1"># then use 3d data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">variable_mapping</span><span class="p">[</span><span class="s1">&#39;x_sea_water_velocity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">variable_mapping</span><span class="p">[</span><span class="s1">&#39;y_sea_water_velocity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">var_name</span> <span class="o">==</span> <span class="s1">&#39;hvel&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_3d</span><span class="p">:</span> <span class="c1"># skip</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">var_name</span> <span class="o">==</span> <span class="s1">&#39;dahv&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_3d</span> <span class="p">:</span> <span class="c1"># skip</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">var_name</span> <span class="o">==</span> <span class="s1">&#39;dahv&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_3d</span><span class="p">:</span> <span class="c1"># then use depth-averaged data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">variable_mapping</span><span class="p">[</span><span class="s1">&#39;x_sea_water_velocity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">variable_mapping</span><span class="p">[</span><span class="s1">&#39;y_sea_water_velocity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># standard mapping</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">variable_mapping</span><span class="p">[</span><span class="n">schism_mapping</span><span class="p">[</span><span class="n">var_name</span><span class="p">]]</span> <span class="o">=</span> \
                        <span class="nb">str</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="c1"># Dictionaries to store blocks of data for reuse (buffering)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_block_before</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Data for last timestep before present</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_block_after</span> <span class="o">=</span> <span class="p">{}</span>   <span class="c1"># Data for first timestep after present</span>

<div class="viewcode-block" id="Reader.get_variables"><a class="viewcode-back" href="../../../autoapi/opendrift/readers/reader_schism_native/index.html#opendrift.readers.reader_schism_native.Reader.get_variables">[docs]</a>    <span class="k">def</span> <span class="nf">get_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">requested_variables</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot; The function extracts &#39;requested_variables&#39; from the native SCHISM files</span>
<span class="sd">            which will then be used in _get_variables_interpolated_() to initialise the ReaderBlockUnstruct objects</span>
<span class="sd">            used to interpolate data in space and time</span>

<span class="sd">            For now the function will extract the entire slice of data of &#39;requested_variables&#39; at given &#39;time&#39;</span>

<span class="sd">            There is an option to extract only a subset of data around particles clouds to have less data but</span>
<span class="sd">            it means we need to recompute the KDtree of the subset nodes every time in ReaderBlockUnstruct.</span>
<span class="sd">            (Speed gain to be tested)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">requested_variables</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">outside</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">check_arguments</span><span class="p">(</span><span class="n">requested_variables</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

        <span class="n">nearestTime</span><span class="p">,</span> <span class="n">dummy1</span><span class="p">,</span> <span class="n">dummy2</span><span class="p">,</span> <span class="n">indxTime</span><span class="p">,</span> <span class="n">dummy3</span><span class="p">,</span> <span class="n">dummy4</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">nearest_time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mf">0.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>
                     <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">nearestTime</span><span class="p">}</span>

        <span class="c1"># extracts the full slices of requested_variables at time indxTime</span>
        <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">requested_variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">par</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;x_sea_water_velocity&#39;</span><span class="p">,</span><span class="s1">&#39;y_sea_water_velocity&#39;</span><span class="p">]</span> <span class="p">:</span>
                <span class="c1"># standard case - for all variables except current velocities</span>
                <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_mapping</span><span class="p">[</span><span class="n">par</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">var</span><span class="p">[:]</span> <span class="c1"># e.g. depth</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;reading constant data from unstructured reader </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">par</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="n">indxTime</span><span class="p">,:]</span> <span class="c1"># e.g. 2D temperature</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;reading 2D data from unstructured reader </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">par</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="n">indxTime</span><span class="p">,:,:]</span> <span class="c1"># e.g. 3D salt [time,node,lev]</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;reading 3D data from unstructured reader </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">par</span><span class="p">))</span>
                    <span class="c1"># convert 3D data matrix to one column array and define corresponding data coordinates [x,y,z]</span>
                    <span class="c1"># (+ update variables dictionary with 3d coords if needed)</span>
                    <span class="n">data</span><span class="p">,</span><span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_3d_to_array</span><span class="p">(</span><span class="n">indxTime</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">variables</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Wrong dimension of </span><span class="si">%s</span><span class="s1">: </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span>
                                     <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_mapping</span><span class="p">[</span><span class="n">par</span><span class="p">],</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="c1"># requested variables are current velocities</span>
                <span class="c1"># In SCHISM netcdf filesboth [u,v] components are saved</span>
                <span class="c1"># as two different dimensions of the same variable.</span>
                <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_mapping</span><span class="p">[</span><span class="n">par</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> <span class="c1"># depth-averaged current data &#39;dahv&#39; defined at each node and time [time,node,2]</span>
                    <span class="k">if</span> <span class="n">par</span> <span class="o">==</span> <span class="s1">&#39;x_sea_water_velocity&#39;</span><span class="p">:</span>
                       <span class="n">data</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="n">indxTime</span><span class="p">,:,</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">par</span> <span class="o">==</span> <span class="s1">&#39;y_sea_water_velocity&#39;</span><span class="p">:</span>
                       <span class="n">data</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="n">indxTime</span><span class="p">,:,</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;reading 2D velocity data from unstructured reader </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">par</span><span class="p">))</span>

                <span class="k">elif</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span> <span class="c1"># #3D current data &#39;hvel&#39; defined at each node, level, and time [time,node,zcor,2]</span>
                    <span class="k">if</span> <span class="n">par</span> <span class="o">==</span> <span class="s1">&#39;x_sea_water_velocity&#39;</span><span class="p">:</span>
                       <span class="n">data</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="n">indxTime</span><span class="p">,:,:,</span><span class="mi">0</span><span class="p">]</span>   <span class="c1">#hvel dimensions : [time,node,lev,2]</span>
                    <span class="k">elif</span> <span class="n">par</span> <span class="o">==</span> <span class="s1">&#39;y_sea_water_velocity&#39;</span><span class="p">:</span>
                       <span class="n">data</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="n">indxTime</span><span class="p">,:,:,</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#hvel dimensions : [time,node,lev,2]</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;reading 3D velocity data from unstructured reader </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">par</span><span class="p">))</span>

                    <span class="c1"># convert 3D data matrix to one column array and define corresponding data coordinates [x,y,z]</span>
                    <span class="c1"># (+ update variables dictionary with 3d coords if needed)</span>
                    <span class="n">data</span><span class="p">,</span><span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_3d_to_array</span><span class="p">(</span><span class="n">indxTime</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">variables</span><span class="p">)</span>

            <span class="n">variables</span><span class="p">[</span><span class="n">par</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span> <span class="c1"># save all data slice to dictionary with key &#39;par&#39;</span>
            <span class="k">if</span> <span class="n">has_xarray</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">variables</span><span class="p">[</span><span class="n">par</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="n">par</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">variables</span></div>

<div class="viewcode-block" id="Reader.convert_3d_to_array"><a class="viewcode-back" href="../../../autoapi/opendrift/readers/reader_schism_native/index.html#opendrift.readers.reader_schism_native.Reader.convert_3d_to_array">[docs]</a>    <span class="k">def</span> <span class="nf">convert_3d_to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">id_time</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">variable_dict</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The function reshapes a data matrix of dimensions = [node,vertical_levels] (i.e. data at vertical levels, at given time step)</span>
<span class="sd">        into a one-column array and works out corresponding 3d coordinates [lon,lat,z] using the time-varying</span>
<span class="sd">        &#39;zcor&#39; variable in SCHISM files (i.e. vertical level positions).</span>

<span class="sd">        These 3D coordinates will be used to build the 3D KDtree for data interpolation and will be added to the &#39;variable_dict&#39;</span>
<span class="sd">        which is eventually passed to get_variables_interpolated().</span>

<span class="sd">        args:</span>
<span class="sd">            -id_time</span>
<span class="sd">            -data</span>
<span class="sd">            -variable_dict</span>
<span class="sd">        out :</span>
<span class="sd">            -flattened &#39;data&#39; array</span>
<span class="sd">            -addition of [&#39;x_3d&#39;,&#39;y_3d&#39;,&#39;z_3d&#39;] items to variable_dict if needed.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">vertical_levels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;zcor&#39;</span><span class="p">][</span><span class="n">id_time</span><span class="p">,:,:]</span>
            <span class="c1"># depth are negative down consistent with convention used in OpenDrift</span>
            <span class="c1"># if using the netCDF4 library, vertical_levels is masked array where &quot;masked&quot; levels are those below seabed  (= 9.9692100e+36)</span>
            <span class="c1"># if using the xarray library, vertical_levels is nan for levels are those below seabed</span>
            <span class="k">if</span> <span class="n">has_xarray</span><span class="p">:</span>
                <span class="c1"># convert to masked array to be consistent with what netCDF4 lib returns</span>
                <span class="n">vertical_levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertical_levels</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vertical_levels</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="c1"># vertical_levels.mask = np.isnan(vertical_levels.data) # masked using nan&#39;s when using xarray</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;no vertical level information present in file &#39;&#39;zcor&#39;&#39; ... stopping&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;variable &#39;&#39;zcor&#39;&#39; must be present in netcdf file to be able to use 3D currents&#39;</span><span class="p">)</span>
        <span class="c1"># flatten 3D data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">vertical_levels</span><span class="o">.</span><span class="n">mask</span><span class="p">])</span>

        <span class="c1"># add corresponding 3D coordinates to the &#39;variable_dict&#39; which is eventually passed to get_variables_interpolated()</span>
        <span class="c1"># Note: these 3d coordinates will be the same for all 3d data (current,salt/temp etc..), and will change at each reader time step</span>
        <span class="c1"># They are saved as [&#39;x_3d&#39;,&#39;y_3d&#39;,&#39;z_3d&#39;] rather than [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;] as it would break things when both 2d and 3d data are requested.</span>
        <span class="k">if</span> <span class="s1">&#39;z_3d&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">variable_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># now make a long 3-column array [lon,lat,z] [n_nodes x  3] at which &#39;data&#39; is defined</span>
            <span class="c1"># tile lon/lat data so that array shape match vertical_levels shape</span>
            <span class="n">x_tiled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,(</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_levels</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span> <span class="c1"># dimensions [node,vertical_levels]</span>
            <span class="n">y_tiled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,(</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_levels</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
            <span class="c1"># lon_tiled = np.tile(self.lon,(self.nb_levels,1)).T # dimensions [node,vertical_levels]</span>
            <span class="c1"># lat_tiled = np.tile(self.lat,(self.nb_levels,1)).T</span>
            <span class="c1"># arrays are tiled so that lon_tiled[0,:] = return same value i.e. same lon/lat for all z levels</span>
            <span class="k">if</span> <span class="n">x_tiled</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">vertical_levels</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">pdb</span><span class="p">;</span><span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
            <span class="c1"># convert to masked array consistent with vertical_levels</span>
            <span class="n">x_tiled_ma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x_tiled</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">vertical_levels</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">y_tiled_ma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y_tiled</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">vertical_levels</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
            <span class="c1"># flatten arrays and add to dictionary</span>
            <span class="n">variable_dict</span><span class="p">[</span><span class="s1">&#39;x_3d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x_tiled_ma</span><span class="p">[</span><span class="o">~</span><span class="n">vertical_levels</span><span class="o">.</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">variable_dict</span><span class="p">[</span><span class="s1">&#39;y_3d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">y_tiled_ma</span><span class="p">[</span><span class="o">~</span><span class="n">vertical_levels</span><span class="o">.</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">variable_dict</span><span class="p">[</span><span class="s1">&#39;z_3d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">vertical_levels</span><span class="p">[</span><span class="o">~</span><span class="n">vertical_levels</span><span class="o">.</span><span class="n">mask</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">data</span><span class="p">,</span><span class="n">variable_dict</span></div>

<div class="viewcode-block" id="Reader._get_variables_interpolated_"><a class="viewcode-back" href="../../../autoapi/opendrift/readers/reader_schism_native/index.html#opendrift.readers.reader_schism_native.Reader._get_variables_interpolated_">[docs]</a>    <span class="k">def</span> <span class="nf">_get_variables_interpolated_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">profiles</span><span class="p">,</span>
                                   <span class="n">profiles_depth</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span>
                                   <span class="n">reader_x</span><span class="p">,</span> <span class="n">reader_y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method _must_ be implemented by every reader. Usually by</span>
<span class="sd">        subclassing one of the reader types (e.g.</span>
<span class="sd">        :class:`structured.StructuredReader`).</span>

<span class="sd">        Arguments are in _native projection_ of reader.</span>

<span class="sd">        .. seealso:</span>

<span class="sd">            * :meth:`get_variables_interpolated_xy`.</span>
<span class="sd">            * :meth:`get_variables_interpolated`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">           Here, this function overloads the _get_variables_interpolated_() methods</span>
<span class="sd">           available in unstructured.py.  (which currently doesnt make use of blocks)</span>

<span class="sd">           The _get_variables_interpolated_() from structured.py uses regularly gridded</span>
<span class="sd">           data &quot;ReaderBlock&quot; extracted from the netcdf files (which may possibly be &quot;cached&quot;</span>
<span class="sd">           for speed improvements - see code for more detail).</span>

<span class="sd">           This function follows a similar approach but is instead using the native</span>
<span class="sd">           high-resolution SCHISM data stored in &quot;ReaderBlockUnstruct&quot; which are used to</span>
<span class="sd">           interpolate data in space and time.</span>

<span class="sd">           The function returns environment data &#39;env&#39; interpolated at particle positions [x,y]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Find reader time_before/time_after</span>
        <span class="n">time_nearest</span><span class="p">,</span> <span class="n">time_before</span><span class="p">,</span> <span class="n">time_after</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">i3</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">nearest_time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Reader time:</span><span class="se">\n\t\t</span><span class="si">%s</span><span class="s1"> (before)</span><span class="se">\n\t\t</span><span class="si">%s</span><span class="s1"> (after)&#39;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">time_before</span><span class="p">,</span> <span class="n">time_after</span><span class="p">))</span>
        <span class="c1"># For variables which are not time dependent, we do not care about time</span>
        <span class="n">static_variables</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sea_floor_depth_below_sea_level&#39;</span><span class="p">,</span> <span class="s1">&#39;land_binary_mask&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">time</span> <span class="o">==</span> <span class="n">time_before</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">static_variables</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">):</span>
            <span class="n">time_after</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">profiles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If profiles are requested for any parameters, we</span>
            <span class="c1"># add two fake points at the end of array to make sure that the</span>
            <span class="c1"># requested block has the depth range required for profiles</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reader_x</span><span class="p">,</span> <span class="p">[</span><span class="n">reader_x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">reader_x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">my</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reader_y</span><span class="p">,</span> <span class="p">[</span><span class="n">reader_y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">reader_y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">mz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="p">[</span><span class="n">profiles_depth</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">profiles_depth</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="n">reader_x</span>
            <span class="n">my</span> <span class="o">=</span> <span class="n">reader_y</span>
            <span class="n">mz</span> <span class="o">=</span> <span class="n">z</span>

        <span class="c1"># start interpolation procedure</span>
        <span class="c1">#</span>
        <span class="c1"># general idea is to create a  new &quot;ReaderBlockUnstruct&quot; class that will be called instead of</span>
        <span class="c1"># the regular &quot;ReaderBlock&quot; as in basereader.py</span>
        <span class="c1"># This allows re-using almost the same code as structured.py for the block_before/block_after</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timer_start</span><span class="p">(</span><span class="s1">&#39;preparing&#39;</span><span class="p">)</span>
        <span class="n">block_before</span> <span class="o">=</span> <span class="n">block_after</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">blockvariables_before</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="n">blockvars_before</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="n">blockvariables_after</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="n">blockvars_after</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">blockvars</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_block_before</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">blockvars</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">):</span>
                <span class="n">block_before</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_block_before</span><span class="p">[</span><span class="n">blockvars</span><span class="p">]</span>
                <span class="n">blockvariables_before</span> <span class="o">=</span> <span class="n">block_before</span><span class="o">.</span><span class="n">data_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="n">blockvars_before</span> <span class="o">=</span> <span class="n">blockvars</span>
                <span class="k">break</span>
            <span class="n">blockvariables_before</span> <span class="o">=</span> <span class="n">variables</span>
            <span class="n">blockvars_before</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">blockvars</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_block_after</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">blockvars</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">):</span>
                <span class="n">block_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_block_after</span><span class="p">[</span><span class="n">blockvars</span><span class="p">]</span>
                <span class="n">blockvariables_after</span> <span class="o">=</span> <span class="n">block_after</span><span class="o">.</span><span class="n">data_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="n">blockvars_after</span> <span class="o">=</span> <span class="n">blockvars</span>
                <span class="k">break</span>

        <span class="c1"># Swap before- and after-blocks if matching times</span>
        <span class="k">if</span> <span class="n">block_before</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">block_after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">block_before</span><span class="o">.</span><span class="n">time</span> <span class="o">!=</span> <span class="n">time_before</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">block_after</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="n">time_before</span><span class="p">:</span>
                    <span class="n">block_before</span> <span class="o">=</span> <span class="n">block_after</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">var_block_before</span><span class="p">[</span><span class="n">blockvars_before</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_before</span>
            <span class="k">if</span> <span class="n">block_after</span><span class="o">.</span><span class="n">time</span> <span class="o">!=</span> <span class="n">time_after</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">block_before</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="n">time_before</span><span class="p">:</span>
                    <span class="n">block_after</span> <span class="o">=</span> <span class="n">block_before</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">var_block_after</span><span class="p">[</span><span class="n">blockvars_after</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_after</span>

        <span class="c1"># Fetch data, if no buffer is available</span>
        <span class="k">if</span> <span class="n">block_before</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> \
                <span class="n">block_before</span><span class="o">.</span><span class="n">time</span> <span class="o">!=</span> <span class="n">time_before</span><span class="p">:</span>
            <span class="n">reader_data_dict</span> <span class="o">=</span> \
                 <span class="bp">self</span><span class="o">.</span><span class="n">__convolve_block__</span><span class="p">(</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">get_variables</span><span class="p">(</span><span class="n">blockvariables_before</span><span class="p">,</span> <span class="n">time_before</span><span class="p">,</span>
                                    <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="n">mz</span><span class="p">))</span>
            <span class="c1"># now use reader_data_dict to initialize</span>
            <span class="c1"># a ReaderBlockUnstruct</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;initialize ReaderBlockUnstruct var_block_before&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">var_block_before</span><span class="p">[</span><span class="n">blockvars_before</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">ReaderBlockUnstruct</span><span class="p">(</span><span class="n">reader_data_dict</span><span class="p">,</span>
                    <span class="n">KDtree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader_KDtree</span><span class="p">,</span>
                    <span class="n">interpolation_horizontal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">len_z</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_block_before</span><span class="p">[</span><span class="n">blockvars_before</span><span class="p">]</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">len_z</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">((</span><span class="s1">&#39;Fetched env-block (size </span><span class="si">%i</span><span class="s1">x</span><span class="si">%i</span><span class="s1">x</span><span class="si">%i</span><span class="s1">) &#39;</span> <span class="o">+</span>
                          <span class="s1">&#39;for time before (</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">)</span> <span class="o">%</span>
                          <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_block_before</span><span class="p">[</span><span class="n">blockvars_before</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">),</span>
                           <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_block_before</span><span class="p">[</span><span class="n">blockvars_before</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
                           <span class="n">len_z</span><span class="p">,</span> <span class="n">time_before</span><span class="p">))</span>
            <span class="n">block_before</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_block_before</span><span class="p">[</span><span class="n">blockvars_before</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">block_after</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">block_after</span><span class="o">.</span><span class="n">time</span> <span class="o">!=</span> <span class="n">time_after</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">time_after</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">var_block_after</span><span class="p">[</span><span class="n">blockvars_after</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">block_before</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reader_data_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__convolve_block__</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_variables</span><span class="p">(</span><span class="n">blockvariables_after</span><span class="p">,</span> <span class="n">time_after</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span>
                                       <span class="n">my</span><span class="p">,</span> <span class="n">mz</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">timer_start</span><span class="p">(</span><span class="s1">&#39;preparing&#39;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;initialize ReaderBlockUnstruct var_block_after&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">var_block_after</span><span class="p">[</span><span class="n">blockvars_after</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">ReaderBlockUnstruct</span><span class="p">(</span>
                        <span class="n">reader_data_dict</span><span class="p">,</span>
                        <span class="n">KDtree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader_KDtree</span><span class="p">,</span>
                        <span class="n">interpolation_horizontal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">len_z</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_block_after</span><span class="p">[</span><span class="n">blockvars_after</span><span class="p">]</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">len_z</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">((</span><span class="s1">&#39;Fetched env-block (size </span><span class="si">%i</span><span class="s1">x</span><span class="si">%i</span><span class="s1">x</span><span class="si">%i</span><span class="s1">) &#39;</span> <span class="o">+</span>
                              <span class="s1">&#39;for time after (</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="p">)</span> <span class="o">%</span>
                              <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_block_after</span><span class="p">[</span><span class="n">blockvars_after</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">),</span>
                               <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_block_after</span><span class="p">[</span><span class="n">blockvars_after</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
                               <span class="n">len_z</span><span class="p">,</span> <span class="n">time_after</span><span class="p">))</span>
                <span class="n">block_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_block_after</span><span class="p">[</span><span class="n">blockvars_after</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">block_before</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">block_before</span><span class="o">.</span><span class="n">covers_positions</span><span class="p">(</span>
            <span class="n">reader_x</span><span class="p">,</span> <span class="n">reader_y</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>\
            <span class="n">block_after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">block_after</span><span class="o">.</span><span class="n">covers_positions</span><span class="p">(</span>
                <span class="n">reader_x</span><span class="p">,</span> <span class="n">reader_y</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">pdb</span><span class="p">;</span><span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Data block from </span><span class="si">%s</span><span class="s1"> not large enough to &#39;</span>
                            <span class="s1">&#39;cover element positions within timestep. &#39;</span>
                            <span class="s1">&#39;Buffer size (</span><span class="si">%s</span><span class="s1">) must be increased.&#39;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timer_end</span><span class="p">(</span><span class="s1">&#39;preparing&#39;</span><span class="p">)</span>

        <span class="c1">############################################################</span>
        <span class="c1"># Interpolate before/after blocks onto particles in space</span>
        <span class="c1">############################################################</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timer_start</span><span class="p">(</span><span class="s1">&#39;interpolation&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Interpolating before (</span><span class="si">%s</span><span class="s1">) in space  (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">block_before</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span><span class="p">))</span>
        <span class="n">env_before</span><span class="p">,</span> <span class="n">env_profiles_before</span> <span class="o">=</span> <span class="n">block_before</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
                <span class="n">reader_x</span><span class="p">,</span> <span class="n">reader_y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span>
                <span class="n">profiles</span><span class="p">,</span> <span class="n">profiles_depth</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">time_after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">time_before</span> <span class="o">!=</span> <span class="n">time</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Interpolating after (</span><span class="si">%s</span><span class="s1">) in space  (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span>
                          <span class="p">(</span><span class="n">block_after</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span><span class="p">))</span>
            <span class="n">env_after</span><span class="p">,</span> <span class="n">env_profiles_after</span> <span class="o">=</span> <span class="n">block_after</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
                    <span class="n">reader_x</span><span class="p">,</span> <span class="n">reader_y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span>
                    <span class="n">profiles</span><span class="p">,</span> <span class="n">profiles_depth</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timer_end</span><span class="p">(</span><span class="s1">&#39;interpolation&#39;</span><span class="p">)</span>
        <span class="c1">#######################</span>
        <span class="c1"># Time interpolation</span>
        <span class="c1">#######################</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timer_start</span><span class="p">(</span><span class="s1">&#39;interpolation_time&#39;</span><span class="p">)</span>
        <span class="n">env_profiles</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">time_after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">time_before</span> <span class="o">!=</span> <span class="n">time</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_block</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">weight_after</span> <span class="o">=</span> <span class="p">((</span><span class="n">time</span> <span class="o">-</span> <span class="n">time_before</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span>
                            <span class="p">(</span><span class="n">time_after</span> <span class="o">-</span> <span class="n">time_before</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">())</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">((</span><span class="s1">&#39;Interpolating before (</span><span class="si">%s</span><span class="s1">, weight </span><span class="si">%.2f</span><span class="s1">) and&#39;</span>
                           <span class="s1">&#39;</span><span class="se">\n\t\t</span><span class="s1">      after (</span><span class="si">%s</span><span class="s1">, weight </span><span class="si">%.2f</span><span class="s1">) in time&#39;</span><span class="p">)</span> <span class="o">%</span>
                          <span class="p">(</span><span class="n">block_before</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">weight_after</span><span class="p">,</span>
                           <span class="n">block_after</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">weight_after</span><span class="p">))</span>
            <span class="n">env</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="c1"># Weighting together, and masking invalid entries</span>
                <span class="n">env</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">((</span><span class="n">env_before</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">*</span>
                                                <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">weight_after</span><span class="p">)</span> <span class="o">+</span>
                                                <span class="n">env_after</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">*</span> <span class="n">weight_after</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">standard_names</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">invalid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">env</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">standard_names</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="s1">&#39;valid_min&#39;</span><span class="p">])</span>
                               <span class="o">|</span> <span class="p">(</span><span class="n">env</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">standard_names</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="s1">&#39;valid_max&#39;</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">invalid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Invalid values found for &#39;</span> <span class="o">+</span> <span class="n">var</span><span class="p">)</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">env</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="n">invalid</span><span class="p">])</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;(allowed range: [</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">])&#39;</span> <span class="o">%</span>
                                        <span class="p">(</span><span class="n">standard_names</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="s1">&#39;valid_min&#39;</span><span class="p">],</span>
                                         <span class="n">standard_names</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="s1">&#39;valid_max&#39;</span><span class="p">]))</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Replacing with NaN&#39;</span><span class="p">)</span>
                        <span class="n">env</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="n">invalid</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="c1"># Interpolating vertical profiles in time</span>
            <span class="k">if</span> <span class="n">profiles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">env_profiles</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Interpolating profiles in time&#39;</span><span class="p">)</span>
                <span class="c1"># Truncating layers not present both before and after</span>
                <span class="n">numlayers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">env_profiles_before</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]),</span>
                                       <span class="nb">len</span><span class="p">(</span><span class="n">env_profiles_after</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]))</span>
                <span class="n">env_profiles</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">env_profiles_before</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">numlayers</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">env_profiles_before</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">var</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">env_profiles_before</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">env_profiles_before</span><span class="p">[</span><span class="n">var</span><span class="p">])</span>
                    <span class="n">env_profiles_after</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">env_profiles_after</span><span class="p">[</span><span class="n">var</span><span class="p">])</span>
                    <span class="n">env_profiles</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">env_profiles_before</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">numlayers</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span>
                        <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">weight_after</span><span class="p">)</span> <span class="o">+</span>
                        <span class="n">env_profiles_after</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">numlayers</span><span class="p">,</span> <span class="p">:]</span><span class="o">*</span><span class="n">weight_after</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">env_profiles</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;No time interpolation needed - right on time.&#39;</span><span class="p">)</span>
            <span class="n">env</span> <span class="o">=</span> <span class="n">env_before</span>
            <span class="k">if</span> <span class="n">profiles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;env_profiles_before&#39;</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
                    <span class="n">env_profiles</span> <span class="o">=</span> <span class="n">env_profiles_before</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Copying data from environment to vertical profiles</span>
                    <span class="n">env_profiles</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">profiles_depth</span><span class="p">}</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">profiles</span><span class="p">:</span>
                        <span class="n">env_profiles</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">env</span><span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="n">env</span><span class="p">[</span><span class="n">var</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timer_end</span><span class="p">(</span><span class="s1">&#39;interpolation_time&#39;</span><span class="p">)</span>
        <span class="c1"># the masking, rotation etc.. is done in variables.py get_variables_interpolated_xy()</span>

        <span class="k">return</span> <span class="n">env</span><span class="p">,</span> <span class="n">env_profiles</span></div>

    <span class="c1"># copied from StructuredReader</span>
<div class="viewcode-block" id="Reader.set_convolution_kernel"><a class="viewcode-back" href="../../../autoapi/opendrift/readers/reader_schism_native/index.html#opendrift.readers.reader_schism_native.Reader.set_convolution_kernel">[docs]</a>    <span class="k">def</span> <span class="nf">set_convolution_kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">convolve</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set a convolution kernel or kernel size (of array of ones) used by `get_variables` on read variables.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convolve</span> <span class="o">=</span> <span class="n">convolve</span></div>

<div class="viewcode-block" id="Reader.__convolve_block__"><a class="viewcode-back" href="../../../autoapi/opendrift/readers/reader_schism_native/index.html#opendrift.readers.reader_schism_native.Reader.__convolve_block__">[docs]</a>    <span class="k">def</span> <span class="nf">__convolve_block__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convolve arrays with a kernel, if reader.convolve is set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">convolve</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convolve</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
                <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span> <span class="o">/</span> <span class="n">kernel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kernel</span> <span class="o">=</span> <span class="n">N</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Convolving variables with kernel: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">kernel</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">env</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">]:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">env</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">env</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">env</span><span class="p">[</span><span class="n">variable</span><span class="p">],</span>
                                                         <span class="n">kernel</span><span class="p">,</span>
                                                         <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">env</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">env</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">env</span><span class="p">[</span><span class="n">variable</span><span class="p">],</span>
                                                         <span class="n">kernel</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">],</span>
                                                         <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">env</span></div>

<div class="viewcode-block" id="Reader.covers_positions_xy"><a class="viewcode-back" href="../../../autoapi/opendrift/readers/reader_schism_native/index.html#opendrift.readers.reader_schism_native.Reader.covers_positions_xy">[docs]</a>    <span class="k">def</span> <span class="nf">covers_positions_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check which points are within boundary of mesh.</span>
<span class="sd">        Wrapper function of covers_positions() from unstructured.py which is called in</span>
<span class="sd">        get_variables_interpolated_xy() function from variables.py</span>
<span class="sd">        It returns indices of in-mesh points, and in-mesh point coordinates rather than a boolean array (inside/outside)</span>
<span class="sd">        Within get_variables_interpolated_xy() from variables.py, data is queried for these in-mesh points only and the</span>
<span class="sd">        full array (incl. out of mesh positions) is re-generated with correct masking</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ind_covered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covers_positions</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ind_covered</span> <span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="n">ind_covered</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">ind_covered</span><span class="p">]</span></div>

<div class="viewcode-block" id="Reader.plot_mesh"><a class="viewcode-back" href="../../../autoapi/opendrift/readers/reader_schism_native/index.html#opendrift.readers.reader_schism_native.Reader.plot_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">plot_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lscale</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span><span class="n">plot_time</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot geographical coverage of reader.&quot;&quot;&quot;</span>

        <span class="c1">#####################################</span>
        <span class="c1"># In Dev - plot unstructured mesh</span>
        <span class="c1">#</span>
        <span class="c1"># To do</span>
        <span class="c1">#  - plot a given timestep, and levels for flows</span>
        <span class="c1">#  - incorporate that to animation as in basemodel.py etc...</span>
        <span class="c1">#</span>
        <span class="c1">#####################################</span>

        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Polygon</span>
        <span class="kn">import</span> <span class="nn">cartopy.crs</span> <span class="k">as</span> <span class="nn">ccrs</span>
        <span class="kn">import</span> <span class="nn">cartopy.feature</span> <span class="k">as</span> <span class="nn">cfeature</span>
        <span class="kn">from</span> <span class="nn">opendrift_landmask_data</span> <span class="kn">import</span> <span class="n">Landmask</span>
        <span class="kn">import</span> <span class="nn">matplotlib.tri</span> <span class="k">as</span> <span class="nn">mtri</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">plot_time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="n">plot_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span>

        <span class="n">corners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy2lonlat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">],</span>
                                 <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ymax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">])</span>
        <span class="n">lonmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">corners</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">buffer</span><span class="o">*</span><span class="mi">2</span>
        <span class="n">lonmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">corners</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">buffer</span><span class="o">*</span><span class="mi">2</span>
        <span class="n">latmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">corners</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">buffer</span>
        <span class="n">latmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">corners</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">buffer</span>
        <span class="n">latspan</span> <span class="o">=</span> <span class="n">latmax</span> <span class="o">-</span> <span class="n">latmin</span>

        <span class="c1"># Initialise map</span>
        <span class="k">if</span> <span class="n">latspan</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
            <span class="c1"># Stereographic projection centred on domain, if small domain</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ymin</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">lon0</span><span class="p">,</span> <span class="n">lat0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy2lonlat</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="n">ccrs</span><span class="o">.</span><span class="n">Stereographic</span><span class="p">(</span><span class="n">central_longitude</span><span class="o">=</span><span class="n">lon0</span><span class="p">,</span> <span class="n">central_latitude</span><span class="o">=</span><span class="n">lat0</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="n">sp</span><span class="p">)</span>
            <span class="n">corners_stere</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">transform_points</span><span class="p">(</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corners</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corners</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Global map if reader domain is large</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="n">ccrs</span><span class="o">.</span><span class="n">Mercator</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="n">sp</span><span class="p">)</span>
            <span class="c1">#map = Basemap(np.array(corners[0]).min(), -89,</span>
            <span class="c1">#              np.array(corners[0]).max(), 89,</span>
            <span class="c1">#              resolution=&#39;c&#39;, projection=&#39;cyl&#39;)</span>

        <span class="c1"># GSHHS coastlines</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">cfeature</span><span class="o">.</span><span class="n">GSHHSFeature</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">lscale</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                  <span class="n">facecolor</span><span class="o">=</span><span class="n">cfeature</span><span class="o">.</span><span class="n">COLORS</span><span class="p">[</span><span class="s1">&#39;land&#39;</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_geometries</span><span class="p">(</span>
            <span class="n">f</span><span class="o">.</span><span class="n">intersecting_geometries</span><span class="p">([</span><span class="n">lonmin</span><span class="p">,</span> <span class="n">lonmax</span><span class="p">,</span> <span class="n">latmin</span><span class="p">,</span> <span class="n">latmax</span><span class="p">]),</span>
            <span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">(),</span>
            <span class="n">facecolor</span><span class="o">=</span><span class="n">cfeature</span><span class="o">.</span><span class="n">COLORS</span><span class="p">[</span><span class="s1">&#39;land&#39;</span><span class="p">],</span>
            <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>

        <span class="n">gl</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">gridlines</span><span class="p">(</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">())</span>
        <span class="n">gl</span><span class="o">.</span><span class="n">xlabels_top</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Get boundary</span>
        <span class="n">npoints</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># points per side</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">]</span><span class="o">*</span><span class="n">npoints</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">]</span><span class="o">*</span><span class="n">npoints</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ymax</span><span class="p">]</span><span class="o">*</span><span class="n">npoints</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">]</span><span class="o">*</span><span class="n">npoints</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ymax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)))</span>
        <span class="c1"># from x/y vectors create a Patch to be added to map</span>
        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy2lonlat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">lat</span><span class="p">[</span><span class="n">lat</span><span class="o">&gt;</span><span class="mi">89</span><span class="p">]</span> <span class="o">=</span> <span class="mf">89.</span>
        <span class="n">lat</span><span class="p">[</span><span class="n">lat</span><span class="o">&lt;-</span><span class="mi">89</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">89.</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">transform_points</span><span class="p">(</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">(),</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
        <span class="n">xsp</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">ysp</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">variable</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># generic plot to check extents</span>
            <span class="n">boundary</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xsp</span><span class="p">,</span> <span class="n">ysp</span><span class="p">)),</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span>
                               <span class="n">zorder</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span>
            <span class="c1"># add nodes</span>
            <span class="n">rx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">])</span>
            <span class="n">ry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span><span class="p">])</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variables</span><span class="p">(</span><span class="s1">&#39;sea_floor_depth_below_sea_level&#39;</span><span class="p">,</span> <span class="n">plot_time</span><span class="p">,</span><span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">rlon</span><span class="p">,</span> <span class="n">rlat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy2lonlat</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">])</span> <span class="c1"># node coordinates</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rlon</span><span class="p">,</span><span class="n">rlat</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">())</span>
            <span class="c1"># set extents</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">xsp</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span><span class="n">xsp</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">*</span><span class="mf">.1</span>  <span class="c1"># Some whitespace around polygon</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_extent</span><span class="p">([</span><span class="n">xsp</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="n">buf</span><span class="p">,</span> <span class="n">xsp</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">buf</span><span class="p">,</span> <span class="n">ysp</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="n">buf</span><span class="p">,</span> <span class="n">ysp</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">buf</span><span class="p">],</span> <span class="n">crs</span><span class="o">=</span><span class="n">sp</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time coverage: </span><span class="si">%s</span><span class="s1"> to </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">variable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># simple scalar variable</span>
                <span class="n">variable</span> <span class="o">=</span> <span class="n">variable</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">rx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span><span class="p">])</span>
                <span class="n">ry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymax</span><span class="p">])</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variables</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">plot_time</span><span class="p">,</span><span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">rlon</span><span class="p">,</span> <span class="n">rlat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy2lonlat</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">])</span> <span class="c1"># node coordinates</span>
                <span class="n">data</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">variable</span><span class="p">])</span>
                <span class="c1"># ax.plot(rlon,rlat, &#39;.&#39;,transform=ccrs.PlateCarree())</span>
                <span class="n">face</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;SCHISM_hgrid_face_nodes&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
                <span class="c1"># build triangulation</span>
                <span class="n">triang</span> <span class="o">=</span><span class="n">mtri</span><span class="o">.</span><span class="n">Triangulation</span><span class="p">(</span><span class="n">rlon</span><span class="p">,</span><span class="n">rlat</span><span class="p">,</span> <span class="n">triangles</span><span class="o">=</span><span class="n">face</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="c1"># plot the variable</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">tricontourf</span><span class="p">(</span><span class="n">triang</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">variable</span><span class="p">],</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ccrs</span><span class="o">.</span><span class="n">PlateCarree</span><span class="p">())</span>
                <span class="c1"># add the triangular mesh - too slow</span>
                <span class="c1"># ax.triplot(triang, transform=ccrs.PlateCarree())</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="s1">&#39;water&#39;</span> <span class="ow">in</span> <span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variable</span><span class="p">):</span>  <span class="c1"># vector field variable = [&#39;x_sea_water_velocity&#39;,&#39;y_sea_water_velocity&#39;]</span>
                <span class="k">pass</span> <span class="c1"># not implemented yet</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">set_extent</span><span class="p">([</span><span class="n">xsp</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="mf">.5</span><span class="p">,</span> <span class="n">xsp</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="mf">.5</span><span class="p">,</span> <span class="n">ysp</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="mf">.5</span><span class="p">,</span> <span class="n">ysp</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="mf">.5</span><span class="p">],</span> <span class="n">crs</span><span class="o">=</span><span class="n">sp</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>  <span class="c1"># Activate figure zooming</span>
            <span class="n">mng</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_current_fig_manager</span><span class="p">()</span>
            <span class="n">mng</span><span class="o">.</span><span class="n">toolbar</span><span class="o">.</span><span class="n">zoom</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="kn">import</span> <span class="nn">pdb</span><span class="p">;</span><span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span></div></div>

<span class="c1">###########################</span>
<span class="c1"># ReaderBlockUnstruct class</span>
<span class="c1">###########################</span>

<span class="c1"># horizontal_interpolation_methods = {</span>
<span class="c1">#     &#39;nearest&#39;: Nearest2DInterpolator,</span>
<span class="c1">#     &#39;ndimage&#39;: NDImage2DInterpolator,</span>
<span class="c1">#     &#39;linearND&#39;: LinearND2DInterpolator,</span>
<span class="c1">#     &#39;linearNDFast&#39;: Linear2DInterpolator}</span>


<span class="c1"># vertical_interpolation_methods = {</span>
<span class="c1">#     &#39;nearest&#39;: Nearest1DInterpolator,</span>
<span class="c1">#     &#39;linear&#39;: Linear1DInterpolator}</span>

<div class="viewcode-block" id="ReaderBlockUnstruct"><a class="viewcode-back" href="../../../autoapi/opendrift/readers/reader_schism_native/index.html#opendrift.readers.reader_schism_native.ReaderBlockUnstruct">[docs]</a><span class="k">class</span> <span class="nc">ReaderBlockUnstruct</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Class to store and interpolate the data from an *unstructured* reader.</span>
<span class="sd">       This is the equivalent of ReaderBlock (regular grid) for *unstructured* grids.</span>

<span class="sd">       arguments: (in addition to ReaderBlock)</span>

<span class="sd">           KDtree : for nearest-neighbor search (initialized using SCHISM nodes in reader&#39;s _init_() )</span>
<span class="sd">                    This is read from reader object, so that it is not recomputed every time</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;opendrift&#39;</span><span class="p">)</span>  <span class="c1"># using common logger</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">,</span>
                 <span class="n">KDtree</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">interpolation_horizontal</span><span class="o">=</span><span class="s1">&#39;linearNDFast&#39;</span><span class="p">,</span>
                 <span class="n">interpolation_vertical</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>

        <span class="c1"># Make pointers to data values, for convenience</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span> <span class="o">=</span> <span class="n">data_dict</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span>
            <span class="c1"># probably not valid ..since z are different for each point in SCHISM..rather than fixed</span>
            <span class="c1"># This is used for the profile interpolation that is not yet functional</span>
            <span class="c1">#</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># if some 3d data is provided, save additional dict entries</span>
        <span class="k">if</span> <span class="s1">&#39;z_3d&#39;</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x_3d</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;x_3d&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_3d</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;y_3d&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z_3d</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;z_3d&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;x_3d&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;y_3d&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;z_3d&#39;</span><span class="p">]</span>

        <span class="c1"># Initialize KDtree(s)</span>
        <span class="c1"># &gt; save the 2D one by default (initizalied during reader __init__()</span>
        <span class="c1"># &gt; compute and save the time-varying 3D KDtree if relevant</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;saving reader&#39;&#39;s 2D (horizontal) KDtree to ReaderBlockUnstruct&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_KDtree</span> <span class="o">=</span> <span class="n">KDtree</span> <span class="c1"># KDtree input to function = one computed during reader&#39;s __init__()</span>

        <span class="c1"># If we eventually use subset of nodes rather than full mesh, we&#39;ll need to re-compute the 2D KDtree</span>
        <span class="c1"># as well, instead of re-using the &quot;full&quot; one available from reader&#39;s init</span>
        <span class="c1"># logger.debug(&#39;Compute time-varying KDtree for 2D nearest-neighbor search&#39;)</span>
        <span class="c1"># self.block_KDtree = cKDTree(np.vstack((self.x,self.y)).T)  # KDtree input to function = one computed during reader&#39;s __init__()</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;z_3d&#39;</span><span class="p">):</span>
            <span class="c1"># we need to compute a new KDtree for that time step using vertical coordinates at that time step</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Compute time-varying KDtree for 3D nearest-neighbor search (i.e using &#39;&#39;zcor&#39;&#39;) &#39;</span><span class="p">)</span>
            <span class="c1"># clean arrays if needed, especially z_3d (get rid of nan&#39;s) - keep only non-nan</span>
            <span class="c1">#</span>
            <span class="c1"># check for nan&#39;s</span>
            <span class="c1"># if (self.z_3d != self.z_3d).any(): # not required</span>
            <span class="c1">#     self.x_3d = self.x_3d[np.where(self.z_3d == self.z_3d)]</span>
            <span class="c1">#     self.y_3d = self.y_3d[np.where(self.z_3d == self.z_3d)]</span>
            <span class="c1">#     self.z_3d = self.z_3d[np.where(self.z_3d == self.z_3d)]</span>
            <span class="c1"># check for infinite values</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_3d</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">z_3d</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_3d</span><span class="p">))]</span> <span class="o">=</span> <span class="mf">15.0</span> <span class="c1">#limit to +15.0m i.e. above msl</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">block_KDtree_3d</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x_3d</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">y_3d</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">z_3d</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="c1"># do we need copy_data=True ..probably not since &quot;data&quot; [self.x_3d,self.y_3d,self.z_3d]</span>
            <span class="c1"># will not change without the KDtree being recomputedplt</span>

        <span class="c1"># Mask any extremely large values, e.g. if missing netCDF _Fill_value</span>
        <span class="n">filled_variables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_outside</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="p">[</span><span class="n">var</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1E+9</span><span class="p">,</span> <span class="mf">1E+9</span><span class="p">)</span>
                <span class="c1"># Convert masked arrays to numpy arrays</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="p">[</span><span class="n">var</span><span class="p">],</span>
                                                   <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="c1"># Fill missing data towards seafloor if 3D</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,)):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Ensemble data currently not extrapolated towards seafloor&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">filled</span> <span class="o">=</span> <span class="n">fill_NaN_towards_seafloor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="p">[</span><span class="n">var</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">filled</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">filled_variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filled_variables</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Filled NaN-values toward seafloor for :&#39;</span>
                          <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">filled_variables</span><span class="p">)))</span>

        <span class="k">if</span> <span class="s1">&#39;land_binary_mask&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> \
                <span class="n">interpolation_horizontal</span> <span class="o">!=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Nearest interpolation will be used &#39;</span>
                          <span class="s1">&#39;for landmask, and </span><span class="si">%s</span><span class="s1"> for other variables&#39;</span>
                          <span class="o">%</span> <span class="n">interpolation_horizontal</span><span class="p">)</span>

<div class="viewcode-block" id="ReaderBlockUnstruct._initialize_interpolator"><a class="viewcode-back" href="../../../autoapi/opendrift/readers/reader_schism_native/index.html#opendrift.readers.reader_schism_native.ReaderBlockUnstruct._initialize_interpolator">[docs]</a>    <span class="k">def</span> <span class="nf">_initialize_interpolator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initialising interpolator.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolator2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Interpolator2DClass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interpolator1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Interpolator1DClass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span></div>

<div class="viewcode-block" id="ReaderBlockUnstruct.interpolate"><a class="viewcode-back" href="../../../autoapi/opendrift/readers/reader_schism_native/index.html#opendrift.readers.reader_schism_native.ReaderBlockUnstruct.interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">profiles</span><span class="o">=</span><span class="p">[],</span> <span class="n">profiles_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Use the KDtree to interpolate data to [x,y,z] particle positions</span>

        <span class="c1"># self._initialize_interpolator(x, y, z)</span>

        <span class="n">env_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">profiles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="p">[]:</span>
            <span class="n">profiles_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">}</span> <span class="c1"># probably not valid...</span>
        <span class="k">for</span> <span class="n">varname</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">nearest</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># land mask</span>
            <span class="k">if</span> <span class="n">varname</span> <span class="o">==</span> <span class="s1">&#39;land_binary_mask&#39;</span><span class="p">:</span>
                <span class="n">nearest</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interpolator2d_nearest</span> <span class="o">=</span> <span class="n">Nearest2DInterpolator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="c1"># ensemble data</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">num_ensembles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Interpolating </span><span class="si">%i</span><span class="s1"> ensembles for </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">num_ensembles</span><span class="p">,</span> <span class="n">varname</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">horizontal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">horizontal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">ensemble_number</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">num_ensembles</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">en</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ensembles</span><span class="p">):</span>
                    <span class="n">elnum</span> <span class="o">=</span> <span class="n">ensemble_number</span> <span class="o">==</span> <span class="n">en</span>
                    <span class="n">int_full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolate_horizontal_layers</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">en</span><span class="p">],</span> <span class="n">nearest</span><span class="o">=</span><span class="n">nearest</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">int_full</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">horizontal</span><span class="p">[</span><span class="n">elnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">int_full</span><span class="p">[</span><span class="n">elnum</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">horizontal</span><span class="p">[:,</span> <span class="n">elnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">int_full</span><span class="p">[:,</span> <span class="n">elnum</span><span class="p">]</span>
            <span class="c1"># standard data 2D or 3D</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># use KDtree to find nearest neighbours and interpolate based on distance, on 2D or 3D</span>
                <span class="c1"># https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.cKDTree.query.html#scipy.spatial.cKDTree.query</span>
                <span class="c1"># print(varname)</span>
                <span class="n">nb_closest_nodes</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="n">DMIN</span><span class="o">=</span><span class="mf">1.e-10</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="c1"># 2D data- full slice</span>
                    <span class="c1">#2D KDtree</span>
                    <span class="n">dist</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">block_KDtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">nb_closest_nodes</span><span class="p">,</span> <span class="n">workers</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#quick nearest-neighbor lookup</span>
                    <span class="c1"># dist = distance to nodes / i = index of nodes</span>
                <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;z_3d&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_3d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">:</span> <span class="c1">#3D data</span>
                    <span class="c1">#3D KDtree</span>
                    <span class="n">dist</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">block_KDtree_3d</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">nb_closest_nodes</span><span class="p">,</span> <span class="n">workers</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#quick nearest-neighbor lookup</span>
                    <span class="c1"># dist = distance to nodes / i = index of nodes</span>
                    <span class="c1">##############################</span>
                    <span class="c1"># PLOT CHECKS</span>
                    <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
                        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_3d</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">y_3d</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">z_3d</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span><span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                    <span class="c1">##############################3</span>

                <span class="n">dist</span><span class="p">[</span><span class="n">dist</span><span class="o">&lt;</span><span class="n">DMIN</span><span class="p">]</span><span class="o">=</span><span class="n">DMIN</span>
                <span class="n">fac</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">dist</span><span class="p">)</span>
                <span class="n">data_interpolated</span> <span class="o">=</span> <span class="p">(</span><span class="n">fac</span><span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">fac</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># horizontal = self._interpolate_horizontal_layers(data, nearest=nearest)</span>

            <span class="k">if</span> <span class="n">profiles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">varname</span> <span class="ow">in</span> <span class="n">profiles</span><span class="p">:</span>
                <span class="c1"># not functional yet...</span>
                <span class="c1"># need to lookup what actually is expected here</span>
                <span class="n">profiles_dict</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_interpolated</span> <span class="c1"># horizontal</span>

            <span class="n">env_dict</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_interpolated</span> <span class="c1">#horizontal</span>

        <span class="k">if</span> <span class="s1">&#39;z&#39;</span> <span class="ow">in</span> <span class="n">profiles_dict</span><span class="p">:</span>
            <span class="n">profiles_dict</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">profiles_dict</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">env_dict</span><span class="p">,</span> <span class="n">profiles_dict</span></div>

<div class="viewcode-block" id="ReaderBlockUnstruct._interpolate_horizontal_layers"><a class="viewcode-back" href="../../../autoapi/opendrift/readers/reader_schism_native/index.html#opendrift.readers.reader_schism_native.ReaderBlockUnstruct._interpolate_horizontal_layers">[docs]</a>    <span class="k">def</span> <span class="nf">_interpolate_horizontal_layers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">nearest</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Interpolate all layers of 3d (or 2d) array.&#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">nearest</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">interpolator2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator2d_nearest</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">interpolator2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator2d</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">interpolator2d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">num_layers</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Allocate output array</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_layers</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">interpolator2d</span><span class="o">.</span><span class="n">x</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_layers</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">layer</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator2d</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">layer</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
            <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="ReaderBlockUnstruct.covers_positions"><a class="viewcode-back" href="../../../autoapi/opendrift/readers/reader_schism_native/index.html#opendrift.readers.reader_schism_native.ReaderBlockUnstruct.covers_positions">[docs]</a>    <span class="k">def</span> <span class="nf">covers_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Check if given positions are covered by this reader block.&#39;&#39;&#39;</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="o">&amp;</span>
                           <span class="p">(</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s1">&#39;r.&#39;</span><span class="p">)</span>
            <span class="n">box</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">()),</span>\
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">()),</span>\
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span>\
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span>\
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">())])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">box</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">box</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;k--&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Increase buffer distance around particle cloud&#39;</span><span class="p">)</span>
            <span class="kn">import</span> <span class="nn">pdb</span><span class="p">;</span><span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Knut-Frode Dagestad (knutfd@met.no) and Gaute Hope (gauteh@met.no)..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>